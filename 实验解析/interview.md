# lazy allocation(lab 5)
## 实现原因：
内核为一个大请求分配和映射内存可能需要很长时间，此外，有些程序申请分配的内存比实际使用的要多（例如，实现稀疏数组），或者为了以后的不时之需而分配内存
## 实现方式：
在申请内存时并不是实际申请物理内存，而是仅仅将虚拟内存增长。等到进程尝试访问该虚拟内存时，会产生一个page fault，并产生内核中断陷入内核态，此时再申请物理内存并将虚拟内存映射过去

.........
# copy on write (lab 6)

## 实现原因：
fork()系统调用将父进程的所有用户空间内存复制到子进程中。如果父进程较大，则复制可能需要很长时间。更糟糕的是，这项工作经常造成大量浪费；例如，子进程中的fork()后跟exec()将导致子进程丢弃复制的内存，而其中的大部分可能都从未使用过
## 实现方式：
fork() 时只将子进程的虚拟地址与父进程的虚拟地址映射到同一块物理地址上，并且将标记位改为可读
当父子进程试图写入是会陷入内核中断，为出错的进程重新分配一页物理地址，复制原来的物理地址的内容，将PTE 标记为可写，然后重新映射虚拟地址到新的页上
在释放时会变得更加棘手，类似于shared_ptr<>,给定的物理页可能会被多个进程的页表引用，并且只有在最后一个引用消失时才应该被释放。

.........
# 用户级线程切换 (lab 7)

## 实现方式：
因为是用户级线程，不需要设计用户栈和内核栈，用户页表和内核页表等等切换，所以本实验中只需要一个类似于context的结构
将寄存器保持在上下文中，添加线程切换语句，恢复sp和ra指针

.........
# free memory list(lab 8)
## 实现原因：
整个内存是一大块整体，当不同进程试图并行分配内存时，会争夺同一把锁，本实验目的是为每个cpu维护一个memory list，导致不会造成对同一个kmem锁的竞争
## 实现方式：
为每个cpu维护一个锁，和空闲内存列表，当该cpu的内存耗尽时窃取其他cpu的空闲内存，它们可用于在进程之间共享内存

........
# mmap
## 实现原因，将文件映射到内存空间，减少磁盘IO以及它们可用于在进程之间共享内存
## 实现方式，在虚拟内存中只分配空间但不映射，陷入中断后分配物理地址，设置标志位，将文件读入，然后映射
